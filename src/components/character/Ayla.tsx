/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.5.3 public/model/ayla.glb -o src/components/character/Ayla.tsx -r public 
*/

import * as THREE from 'three'
import React, { useEffect, useImperativeHandle, forwardRef, useState, useRef } from 'react'
import { useGraph, ThreeElements, useFrame } from '@react-three/fiber'
import { useGLTF, useAnimations } from '@react-three/drei'
import { GLTF, SkeletonUtils } from 'three-stdlib'

type ActionName = 'Armature|6577333224704_TempMotion' | 'Key|6577333224704_TempMotion' | 'Key.002|6577333224704_TempMotion' | 'Key.001|6577333224704_TempMotion' | 'Key.003|6577333224704_TempMotion'

export interface MorphTargetData {
  morphTarget: string;
  weight: string;
}

// AllowedMeshNames might not be needed externally anymore if the method always targets specific meshes
// export type AllowedMeshNames = 'CC_Base_Body_2' | 'CC_Base_Body_9';

export interface AylaModelRef {
  updateMorphTargets: (targets: MorphTargetData[]) => void; // meshName parameter removed
}

interface GLTFAction extends THREE.AnimationClip {
  name: ActionName
}

type GLTFResult = GLTF & {
  nodes: {
    Bang: THREE.SkinnedMesh
    Bun: THREE.SkinnedMesh
    Hair_Base_1: THREE.SkinnedMesh
    Hair_Base_2: THREE.SkinnedMesh
    High_Heels: THREE.SkinnedMesh
    Knee_length_skirt: THREE.SkinnedMesh
    Real_Hair: THREE.SkinnedMesh
    Rolled_sleeves_shirt: THREE.SkinnedMesh
    Underwear_Bottoms: THREE.SkinnedMesh
    CC_Base_Body_1: THREE.SkinnedMesh
    CC_Base_Body_2: THREE.SkinnedMesh // Target Mesh
    CC_Base_Body_3: THREE.SkinnedMesh
    CC_Base_Body_4: THREE.SkinnedMesh
    CC_Base_Body_5: THREE.SkinnedMesh
    CC_Base_Body_6: THREE.SkinnedMesh
    CC_Base_Body_7: THREE.SkinnedMesh
    CC_Base_Body_8: THREE.SkinnedMesh
    CC_Base_Body_9: THREE.SkinnedMesh // Target Mesh
    CC_Base_Body_10: THREE.SkinnedMesh
    CC_Base_Body_11: THREE.SkinnedMesh
    CC_Base_Body_12: THREE.SkinnedMesh
    CC_Base_Body_13: THREE.SkinnedMesh
    CC_Base_EyeOcclusion_1: THREE.SkinnedMesh
    CC_Base_EyeOcclusion_2: THREE.SkinnedMesh
    CC_Base_TearLine_1: THREE.SkinnedMesh
    CC_Base_TearLine_2: THREE.SkinnedMesh
    Female_Angled_1: THREE.SkinnedMesh
    Female_Angled_2: THREE.SkinnedMesh
    CC_Base_BoneRoot: THREE.Bone
  }
  materials: {
    ['Hair_Transparency.003']: THREE.MeshStandardMaterial
    ['Hair_Transparency.001']: THREE.MeshStandardMaterial
    Hair_Transparency: THREE.MeshStandardMaterial
    Scalp_Transparency: THREE.MeshStandardMaterial
    High_Heels: THREE.MeshStandardMaterial
    Knee_length_skirt: THREE.MeshStandardMaterial
    ['Hair_Transparency.002']: THREE.MeshStandardMaterial
    Rolled_sleeves_shirt: THREE.MeshStandardMaterial
    Underwear_Bottoms: THREE.MeshStandardMaterial
    Std_Tongue: THREE.MeshStandardMaterial
    Std_Skin_Head: THREE.MeshStandardMaterial
    Std_Skin_Body: THREE.MeshStandardMaterial
    Std_Skin_Arm: THREE.MeshStandardMaterial
    Std_Skin_Leg: THREE.MeshStandardMaterial
    Std_Nails: THREE.MeshStandardMaterial
    Std_Eyelash: THREE.MeshStandardMaterial
    Std_Upper_Teeth: THREE.MeshStandardMaterial
    Std_Lower_Teeth: THREE.MeshStandardMaterial
    Std_Eye_R: THREE.MeshStandardMaterial
    Std_Cornea_R: THREE.MeshStandardMaterial
    Std_Eye_L: THREE.MeshStandardMaterial
    Std_Cornea_L: THREE.MeshStandardMaterial
    Std_Eye_Occlusion_R: THREE.MeshStandardMaterial
    Std_Eye_Occlusion_L: THREE.MeshStandardMaterial
    Std_Tearline_R: THREE.MeshStandardMaterial
    Std_Tearline_L: THREE.MeshStandardMaterial
    Female_Angled_Transparency: THREE.MeshStandardMaterial
    Female_Angled_Base_Transparency: THREE.MeshStandardMaterial
  }
  animations: GLTFAction[]
}

export const Model = forwardRef<AylaModelRef, ThreeElements['group']>((props, ref) => {
  const group = React.useRef<THREE.Group>(null!)
  const { scene, animations: characterAnimations } = useGLTF('/model/ayla.glb')
  const { animations: motionAnimations } = useGLTF('/model/motion.glb')
  
  const animations = React.useMemo(() => 
    [...characterAnimations, ...motionAnimations], 
    [characterAnimations, motionAnimations]
  )
  
  const clone = React.useMemo(() => SkeletonUtils.clone(scene), [scene])
  const { nodes, materials } = useGraph(clone) as unknown as Pick<GLTFResult, 'nodes' | 'materials'>
  const { actions } = useAnimations(animations, group)
  
  // Göz qırpma üçün state'lər
  const blinkTimeoutRef = useRef<NodeJS.Timeout | null>(null)
  const [blinkState, setBlinkState] = useState<'open' | 'closing' | 'closed' | 'opening'>('open')
  const [blinkProgress, setBlinkProgress] = useState(0)
  const nextBlinkTimeRef = useRef(0)
  
  // Göz qırpmağı planlaşdır
  const scheduleNextBlink = () => {
    if (blinkTimeoutRef.current) {
      clearTimeout(blinkTimeoutRef.current);
    }
    
    // Random olaraq 10-15 saniyə arasında bir göz qırpma
    const nextBlinkDelay = 10000 + Math.random() * 5000;
    nextBlinkTimeRef.current = Date.now() + nextBlinkDelay;
    
    blinkTimeoutRef.current = setTimeout(() => {
      // Göz qırpma başlat
      setBlinkState('closing');
      setBlinkProgress(0);
    }, nextBlinkDelay);
  };

  // Göz qırpma üçün morph targetlərini yeniləmək
  const updateEyeBlinkMorphs = (weight: number) => {
    // Göz qapaqları (CC_Base_Body_2) üçün morph target
    const headMesh = nodes['CC_Base_Body_2'] as THREE.SkinnedMesh;
    if (headMesh && headMesh.morphTargetDictionary && headMesh.morphTargetInfluences) {
      // Sol göz
      const blinkLeftIndex = headMesh.morphTargetDictionary['Eye_Blink_L'];
      if (blinkLeftIndex !== undefined) {
        headMesh.morphTargetInfluences[blinkLeftIndex] = weight;
      }
      
      // Sağ göz
      const blinkRightIndex = headMesh.morphTargetDictionary['Eye_Blink_R'];
      if (blinkRightIndex !== undefined) {
        headMesh.morphTargetInfluences[blinkRightIndex] = weight;
      }
    }
    
    // Kirpiklər (CC_Base_Body_7) üçün morph target
    const eyelashMesh = nodes['CC_Base_Body_7'] as THREE.SkinnedMesh;
    if (eyelashMesh && eyelashMesh.morphTargetDictionary && eyelashMesh.morphTargetInfluences) {
      // Sol kirpik
      const blinkLeftIndex = eyelashMesh.morphTargetDictionary['Eye_Blink_L'];
      if (blinkLeftIndex !== undefined) {
        eyelashMesh.morphTargetInfluences[blinkLeftIndex] = weight;
      }
      
      // Sağ kirpik
      const blinkRightIndex = eyelashMesh.morphTargetDictionary['Eye_Blink_R'];
      if (blinkRightIndex !== undefined) {
        eyelashMesh.morphTargetInfluences[blinkRightIndex] = weight;
      }
    }
  };

  // Hər frame'də göz qırpma animasiyasını yeniləmək üçün
  useFrame((_, delta) => {
    // Göz qırpma animasiyası
    if (blinkState === 'closing') {
      // Gözü bağlama (0.1 saniyə)
      setBlinkProgress(blinkProgress + delta * 10);
      
      // Transition
      updateEyeBlinkMorphs(Math.min(blinkProgress, 1));
      
      if (blinkProgress >= 1) {
        setBlinkState('closed');
        setBlinkProgress(0);
      }
    } 
    else if (blinkState === 'closed') {
      // Gözün bağlı qalma müddəti (0.05 saniyə)
      setBlinkProgress(blinkProgress + delta * 20);
      
      if (blinkProgress >= 1) {
        setBlinkState('opening');
        setBlinkProgress(0);
      }
    }
    else if (blinkState === 'opening') {
      // Gözü açma (0.15 saniyə)
      setBlinkProgress(blinkProgress + delta * 6.67);
      
      // Transition
      updateEyeBlinkMorphs(Math.max(1 - blinkProgress, 0));
      
      if (blinkProgress >= 1) {
        setBlinkState('open');
        setBlinkProgress(0);
        // Növbəti göz qırpmanı planlaşdır
        scheduleNextBlink();
      }
    }
  });
  
  useImperativeHandle(ref, () => ({
    updateMorphTargets: (targets: MorphTargetData[]) => {
      const targetMeshNames = ['CC_Base_Body_2', 'CC_Base_Body_9'] as const; // Apply to both meshes

      targetMeshNames.forEach(meshName => {
        const meshNode = nodes[meshName] as THREE.SkinnedMesh;

        if (meshNode && meshNode.morphTargetDictionary && meshNode.morphTargetInfluences) {
          // Optional: Reset all other morphs on this mesh to 0 first
          // This ensures that only the specified morphs are active.
          // If you want morphs to be additive without this, comment out the next loop.
          for (let i = 0; i < meshNode.morphTargetInfluences.length; i++) {
            meshNode.morphTargetInfluences[i] = 0;
          }

          targets.forEach(targetData => {
            const morphTargetIndex = meshNode.morphTargetDictionary![targetData.morphTarget];
            if (morphTargetIndex !== undefined) {
              const weightValue = parseFloat(targetData.weight);
              if (!isNaN(weightValue)) {
                meshNode.morphTargetInfluences![morphTargetIndex] = weightValue;
              } else {
                console.warn(`[Ayla.tsx] Invalid weight value for morph target "${targetData.morphTarget}" on mesh "${meshName}": ${targetData.weight}`);
              }
            } else {
              console.warn(`[Ayla.tsx] Morph target "${targetData.morphTarget}" not found in dictionary for mesh "${meshName}". Available targets:`, Object.keys(meshNode.morphTargetDictionary!));
            }
          });
        } else {
          let errorMsg = `[Ayla.tsx] Failed to update morph targets for mesh "${meshName}".`;
          if (!meshNode) {
              errorMsg += ` Mesh node not found. Available nodes: ${Object.keys(nodes).join(', ')}.`;
          } else if (!meshNode.morphTargetDictionary) {
              errorMsg += ` morphTargetDictionary not found.`;
          } else if (!meshNode.morphTargetInfluences) {
              errorMsg += ` morphTargetInfluences not found.`;
          }
          console.warn(errorMsg);
        }
      });
    }
  }));
  
  useEffect(() => {
    const animationNames = Object.keys(actions)
    
    if (animationNames.length > 0) {
      const firstAnimation = actions[animationNames[0]]
      if (firstAnimation) { 
        firstAnimation.reset().fadeIn(0.5).play()
      }
    }
    
    // İlk göz qırpmanı planlaşdır
    scheduleNextBlink();
    
    return () => {
      Object.values(actions).forEach(action => action?.fadeOut(0.5))
      if (blinkTimeoutRef.current) {
        clearTimeout(blinkTimeoutRef.current);
      }
    }
  }, [actions])
  
  return (
    <group ref={group} {...props} dispose={null}>
      <group name="Scene">
        <group name="Armature" scale={0.01}>
          <primitive object={nodes.CC_Base_BoneRoot} />
          <skinnedMesh name="Bang" geometry={nodes.Bang.geometry} material={materials['Hair_Transparency.003']} skeleton={nodes.Bang.skeleton} />
          <skinnedMesh name="Bun" geometry={nodes.Bun.geometry} material={materials['Hair_Transparency.001']} skeleton={nodes.Bun.skeleton} />
          <group name="Hair_Base">
            <skinnedMesh name="Hair_Base_1" geometry={nodes.Hair_Base_1.geometry} material={materials.Hair_Transparency} skeleton={nodes.Hair_Base_1.skeleton} />
            <skinnedMesh name="Hair_Base_2" geometry={nodes.Hair_Base_2.geometry} material={materials.Scalp_Transparency} skeleton={nodes.Hair_Base_2.skeleton} />
          </group>
          <skinnedMesh name="High_Heels" geometry={nodes.High_Heels.geometry} material={materials.High_Heels} skeleton={nodes.High_Heels.skeleton} />
          <skinnedMesh name="Knee_length_skirt" geometry={nodes.Knee_length_skirt.geometry} material={materials.Knee_length_skirt} skeleton={nodes.Knee_length_skirt.skeleton} />
          <skinnedMesh name="Real_Hair" geometry={nodes.Real_Hair.geometry} material={materials['Hair_Transparency.002']} skeleton={nodes.Real_Hair.skeleton} />
          <skinnedMesh name="Rolled_sleeves_shirt" geometry={nodes.Rolled_sleeves_shirt.geometry} material={materials.Rolled_sleeves_shirt} skeleton={nodes.Rolled_sleeves_shirt.skeleton} />
          <skinnedMesh name="Underwear_Bottoms" geometry={nodes.Underwear_Bottoms.geometry} material={materials.Underwear_Bottoms} skeleton={nodes.Underwear_Bottoms.skeleton} />
          <group name="CC_Base_Body">
            <skinnedMesh name="CC_Base_Body_1" geometry={nodes.CC_Base_Body_1.geometry} material={materials.Std_Tongue} skeleton={nodes.CC_Base_Body_1.skeleton} morphTargetDictionary={nodes.CC_Base_Body_1.morphTargetDictionary} morphTargetInfluences={nodes.CC_Base_Body_1.morphTargetInfluences} />
            <skinnedMesh name="CC_Base_Body_2" geometry={nodes.CC_Base_Body_2.geometry} material={materials.Std_Skin_Head} skeleton={nodes.CC_Base_Body_2.skeleton} morphTargetDictionary={nodes.CC_Base_Body_2.morphTargetDictionary} morphTargetInfluences={nodes.CC_Base_Body_2.morphTargetInfluences} />
            <skinnedMesh name="CC_Base_Body_3" geometry={nodes.CC_Base_Body_3.geometry} material={materials.Std_Skin_Body} skeleton={nodes.CC_Base_Body_3.skeleton} morphTargetDictionary={nodes.CC_Base_Body_3.morphTargetDictionary} morphTargetInfluences={nodes.CC_Base_Body_3.morphTargetInfluences} />
            <skinnedMesh name="CC_Base_Body_4" geometry={nodes.CC_Base_Body_4.geometry} material={materials.Std_Skin_Arm} skeleton={nodes.CC_Base_Body_4.skeleton} morphTargetDictionary={nodes.CC_Base_Body_4.morphTargetDictionary} morphTargetInfluences={nodes.CC_Base_Body_4.morphTargetInfluences} />
            <skinnedMesh name="CC_Base_Body_5" geometry={nodes.CC_Base_Body_5.geometry} material={materials.Std_Skin_Leg} skeleton={nodes.CC_Base_Body_5.skeleton} morphTargetDictionary={nodes.CC_Base_Body_5.morphTargetDictionary} morphTargetInfluences={nodes.CC_Base_Body_5.morphTargetInfluences} />
            <skinnedMesh name="CC_Base_Body_6" geometry={nodes.CC_Base_Body_6.geometry} material={materials.Std_Nails} skeleton={nodes.CC_Base_Body_6.skeleton} morphTargetDictionary={nodes.CC_Base_Body_6.morphTargetDictionary} morphTargetInfluences={nodes.CC_Base_Body_6.morphTargetInfluences} />
            <skinnedMesh name="CC_Base_Body_7" geometry={nodes.CC_Base_Body_7.geometry} material={materials.Std_Eyelash} skeleton={nodes.CC_Base_Body_7.skeleton} morphTargetDictionary={nodes.CC_Base_Body_7.morphTargetDictionary} morphTargetInfluences={nodes.CC_Base_Body_7.morphTargetInfluences} />
            <skinnedMesh name="CC_Base_Body_8" geometry={nodes.CC_Base_Body_8.geometry} material={materials.Std_Upper_Teeth} skeleton={nodes.CC_Base_Body_8.skeleton} morphTargetDictionary={nodes.CC_Base_Body_8.morphTargetDictionary} morphTargetInfluences={nodes.CC_Base_Body_8.morphTargetInfluences} />
            <skinnedMesh name="CC_Base_Body_9" geometry={nodes.CC_Base_Body_9.geometry} material={materials.Std_Lower_Teeth} skeleton={nodes.CC_Base_Body_9.skeleton} morphTargetDictionary={nodes.CC_Base_Body_9.morphTargetDictionary} morphTargetInfluences={nodes.CC_Base_Body_9.morphTargetInfluences} />
            <skinnedMesh name="CC_Base_Body_10" geometry={nodes.CC_Base_Body_10.geometry} material={materials.Std_Eye_R} skeleton={nodes.CC_Base_Body_10.skeleton} morphTargetDictionary={nodes.CC_Base_Body_10.morphTargetDictionary} morphTargetInfluences={nodes.CC_Base_Body_10.morphTargetInfluences} />
            <skinnedMesh name="CC_Base_Body_11" geometry={nodes.CC_Base_Body_11.geometry} material={materials.Std_Cornea_R} skeleton={nodes.CC_Base_Body_11.skeleton} morphTargetDictionary={nodes.CC_Base_Body_11.morphTargetDictionary} morphTargetInfluences={nodes.CC_Base_Body_11.morphTargetInfluences} />
            <skinnedMesh name="CC_Base_Body_12" geometry={nodes.CC_Base_Body_12.geometry} material={materials.Std_Eye_L} skeleton={nodes.CC_Base_Body_12.skeleton} morphTargetDictionary={nodes.CC_Base_Body_12.morphTargetDictionary} morphTargetInfluences={nodes.CC_Base_Body_12.morphTargetInfluences} />
            <skinnedMesh name="CC_Base_Body_13" geometry={nodes.CC_Base_Body_13.geometry} material={materials.Std_Cornea_L} skeleton={nodes.CC_Base_Body_13.skeleton} morphTargetDictionary={nodes.CC_Base_Body_13.morphTargetDictionary} morphTargetInfluences={nodes.CC_Base_Body_13.morphTargetInfluences} />
          </group>
          <group name="CC_Base_EyeOcclusion">
            <skinnedMesh name="CC_Base_EyeOcclusion_1" geometry={nodes.CC_Base_EyeOcclusion_1.geometry} material={materials.Std_Eye_Occlusion_R} skeleton={nodes.CC_Base_EyeOcclusion_1.skeleton} morphTargetDictionary={nodes.CC_Base_EyeOcclusion_1.morphTargetDictionary} morphTargetInfluences={nodes.CC_Base_EyeOcclusion_1.morphTargetInfluences} />
            <skinnedMesh name="CC_Base_EyeOcclusion_2" geometry={nodes.CC_Base_EyeOcclusion_2.geometry} material={materials.Std_Eye_Occlusion_L} skeleton={nodes.CC_Base_EyeOcclusion_2.skeleton} morphTargetDictionary={nodes.CC_Base_EyeOcclusion_2.morphTargetDictionary} morphTargetInfluences={nodes.CC_Base_EyeOcclusion_2.morphTargetInfluences} />
          </group>
          <group name="CC_Base_TearLine">
            <skinnedMesh name="CC_Base_TearLine_1" geometry={nodes.CC_Base_TearLine_1.geometry} material={materials.Std_Tearline_R} skeleton={nodes.CC_Base_TearLine_1.skeleton} morphTargetDictionary={nodes.CC_Base_TearLine_1.morphTargetDictionary} morphTargetInfluences={nodes.CC_Base_TearLine_1.morphTargetInfluences} />
            <skinnedMesh name="CC_Base_TearLine_2" geometry={nodes.CC_Base_TearLine_2.geometry} material={materials.Std_Tearline_L} skeleton={nodes.CC_Base_TearLine_2.skeleton} morphTargetDictionary={nodes.CC_Base_TearLine_2.morphTargetDictionary} morphTargetInfluences={nodes.CC_Base_TearLine_2.morphTargetInfluences} />
          </group>
          <group name="Female_Angled">
            <skinnedMesh name="Female_Angled_1" geometry={nodes.Female_Angled_1.geometry} material={materials.Female_Angled_Transparency} skeleton={nodes.Female_Angled_1.skeleton} morphTargetDictionary={nodes.Female_Angled_1.morphTargetDictionary} morphTargetInfluences={nodes.Female_Angled_1.morphTargetInfluences} />
            <skinnedMesh name="Female_Angled_2" geometry={nodes.Female_Angled_2.geometry} material={materials.Female_Angled_Base_Transparency} skeleton={nodes.Female_Angled_2.skeleton} morphTargetDictionary={nodes.Female_Angled_2.morphTargetDictionary} morphTargetInfluences={nodes.Female_Angled_2.morphTargetInfluences} />
          </group>
        </group>
      </group>
    </group>
  )
})

Model.displayName = 'AylaModel'

useGLTF.preload('/model/ayla.glb')
useGLTF.preload('/model/motion.glb')
